\subsection{Implementation Tasks}

This assignment consists of four main implementation tasks that build upon each other to create a complete path tracer. Each task has been carefully designed to teach specific concepts in physically-based rendering while maintaining reasonable implementation complexity. Students should implement these tasks in order, as later tasks depend on earlier ones. The provided framework handles all system-level complexities, allowing you to focus entirely on the graphics algorithms.

You will be working in four main files:
\begin{itemize}
\item \texttt{primitive.c}: Ray-primitive intersection algorithms (Task 1)
\item \texttt{material.c}: Material scattering functions (Task 2)
\item \texttt{pathtracer.c}: Main path tracing algorithm (Task 3)
\item \texttt{bvh.c}: BVH construction and traversal (Task 4)
\end{itemize}

Total points for this assignment: 100 points, distributed across the core path tracing components.

\subsubsection{Task 1: Ray-Primitive Intersection (25 points) - File: primitive.c}

The foundation of any ray tracer is the ability to determine where rays intersect with geometric primitives. In this task, you will implement intersection algorithms for spheres and triangles in \texttt{primitive.c}. These algorithms must be both correct and efficient, as they will be called billions of times during a typical render. The mathematical concepts were covered in the theory section, and now you'll translate those equations into working code.

\textbf{Subtask 1.1: Ray-Sphere Intersection (12 points)}

Implement the \texttt{sphere\_hit} function in \texttt{primitive.c}. This function takes a ray, a sphere, and a valid t range, returning whether an intersection exists and filling in the hit record if it does. Your implementation should:

\begin{itemize}
\item Solve the quadratic equation derived from substituting the ray equation into the sphere equation
\item Handle the discriminant correctly: negative means no intersection, zero means one tangent intersection, positive means two intersections
\item Choose the correct t value: the smallest positive t within the valid range [t\_min, t\_max]
\item Compute the hit point using the ray equation: $\mathbf{p} = \mathbf{o} + t\mathbf{d}$
\item Calculate the outward-facing normal: $\mathbf{n} = (\mathbf{p} - \mathbf{c})/r$ where c is center and r is radius
\item Determine if the ray hit the front or back face by checking if the ray direction and normal point in opposite directions
\item Set all fields in the hit record structure correctly
\end{itemize}

\textbf{Subtask 1.2: Ray-Triangle Intersection (13 points)}

Implement the \texttt{triangle\_hit} function using the MÃ¶ller-Trumbore algorithm. This efficient algorithm simultaneously computes the intersection point and barycentric coordinates without requiring pre-computation of the plane equation. Your implementation should:

\begin{itemize}
\item Compute edge vectors: $\mathbf{e_1} = \mathbf{v_1} - \mathbf{v_0}$ and $\mathbf{e_2} = \mathbf{v_2} - \mathbf{v_0}$
\item Calculate the determinant to check if the ray is parallel to the triangle plane
\item Use a small epsilon (e.g., 1e-8) to handle near-parallel cases
\item Compute barycentric coordinates u and v, checking that $u \geq 0$, $v \geq 0$, and $u + v \leq 1$
\item Calculate the t parameter and verify it's within the valid range
\item Compute the intersection point and normal using the cross product of edge vectors
\item Handle both front and back face intersections correctly
\end{itemize}

The algorithm should early-exit when any constraint is violated to maximize efficiency. Pay attention to the order of operations to minimize computational cost for rays that don't intersect the triangle.

\subsubsection{Task 2: Material Scattering (25 points) - File: material.c}

Materials determine how light interacts with surfaces, encoding the visual appearance of objects. In this task, you'll implement three fundamental material types in \texttt{material.c}. Each material must correctly sample the BRDF and compute the probability density function (PDF) for importance sampling. The scattering functions must be energy-conserving to ensure physical correctness.

\textbf{Subtask 2.1: Lambertian Diffuse Material (8 points)}

Implement Lambertian scattering in the \texttt{MATERIAL\_LAMBERTIAN} case of \texttt{material\_scatter}. Lambertian surfaces exhibit perfect diffuse reflection, scattering light equally in all directions above the surface. Your implementation should:

\begin{itemize}
\item Generate a random direction in the hemisphere above the surface using cosine-weighted sampling
\item Use the provided \texttt{random\_unit\_vector()} and ensure the scattered direction is in the same hemisphere as the normal
\item Handle the degenerate case where the random vector is exactly opposite to the normal
\item Set the scattered ray origin at the hit point (offset slightly along the normal to avoid self-intersection)
\item Set the attenuation to the material's albedo color
\item Return true to indicate successful scattering
\end{itemize}

The cosine-weighted sampling is crucial for variance reduction. A common approach is to generate a random unit vector and add it to the normal, then normalize the result. This naturally produces a cosine-weighted distribution.

\textbf{Subtask 2.2: Metal Material with Roughness (8 points)}

Implement metal scattering with controllable roughness. Metals exhibit specular reflection that can be perfect (mirror-like) or rough depending on surface properties. Your implementation should:

\begin{itemize}
\item Compute the mirror reflection direction: $\mathbf{r} = \mathbf{v} - 2(\mathbf{v} \cdot \mathbf{n})\mathbf{n}$ where v is the incident direction
\item Add roughness by perturbing the reflected direction with a random vector scaled by the roughness parameter
\item Ensure the scattered ray is in the correct hemisphere (dot product of scattered direction and normal should be positive)
\item Set the attenuation to the material's albedo (representing the metal's color)
\item Return false if the scattered ray goes below the surface (absorbed)
\end{itemize}

The roughness parameter should range from 0 (perfect mirror) to 1 (very rough). Be careful with the sign conventions for incident and reflected directions.

\textbf{Subtask 2.3: Dielectric Material with Refraction (9 points)}

Implement dielectric (transparent) materials that exhibit both reflection and refraction according to Fresnel equations. This is the most complex material type, requiring careful handling of total internal reflection and Fresnel coefficients. Your implementation should:

\begin{itemize}
\item Determine if the ray is entering or exiting the material by checking the face orientation
\item Calculate the refraction ratio: either $\eta_1/\eta_2$ (entering) or $\eta_2/\eta_1$ (exiting)
\item Compute the cosine of the incident angle
\item Check for total internal reflection: when $\sin\theta_t > 1$ where $\sin\theta_t = \frac{\eta_i}{\eta_t}\sin\theta_i$
\item Use Schlick's approximation for the Fresnel reflectance coefficient
\item Randomly choose between reflection and refraction based on the Fresnel coefficient
\item Compute the refracted direction using Snell's law when refraction occurs
\item Set attenuation to white (vec3(1,1,1)) as dielectrics don't absorb light in our simple model
\end{itemize}

This material type requires the most careful implementation due to the many edge cases and the critical nature of total internal reflection for effects like caustics.

\subsubsection{Task 3: Path Tracing Integration (25 points) - File: pathtracer.c}

The heart of the path tracer is the recursive ray tracing function that follows light paths through the scene. This task requires integrating all previous components into a cohesive Monte Carlo path tracer in \texttt{pathtracer.c}. You'll implement the main rendering equation solver that handles recursive bouncing, Russian roulette termination, and light accumulation. This is where the theory of path tracing becomes practical code.

\textbf{Implementation Requirements:}

Implement the \texttt{trace\_ray} function in \texttt{pathtracer.c} with the following logic:

\begin{itemize}
\item Check recursion depth and implement Russian roulette for unbiased termination:
  \begin{itemize}
  \item For depth > RUSSIAN\_ROULETTE\_DEPTH, compute survival probability based on ray throughput
  \item Use the maximum color component as survival probability (clamped to a reasonable maximum like 0.95)
  \item Randomly terminate paths based on this probability
  \item Scale the contribution of surviving paths by $1/p$ to maintain the correct expected value
  \end{itemize}

\item Find the closest intersection with the scene:
  \begin{itemize}
  \item Use the BVH traversal function (which you'll implement in Task 4)
  \item If no intersection, return the background color (could be sky gradient or constant)
  \item Track the closest hit distance to early-terminate BVH traversal
  \end{itemize}

\item Handle emissive materials:
  \begin{itemize}
  \item Check if the hit material is emissive
  \item Add emission contribution to the accumulated light
  \item Emissive materials should not scatter rays (they only emit, not reflect)
  \end{itemize}

\item Generate scattered rays:
  \begin{itemize}
  \item Call the material scattering function
  \item If scattering fails (absorbed), return the accumulated emission
  \item Otherwise, recursively trace the scattered ray
  \end{itemize}

\item Accumulate contributions:
  \begin{itemize}
  \item Multiply the recursive result by the material attenuation
  \item Add any emission from the current surface
  \item Apply the cosine term implicitly handled by importance sampling
  \end{itemize}
\end{itemize}

The function should handle edge cases gracefully: rays that immediately leave the scene, numerical precision issues at surface intersections, and degenerate scattering directions. Use a small epsilon offset when spawning secondary rays to avoid self-intersection artifacts.

\subsubsection{Task 4: BVH Acceleration Structure (25 points) - File: bvh.c}

The Bounding Volume Hierarchy dramatically accelerates ray tracing by organizing primitives into a tree structure that allows rapid culling of non-intersecting geometry. Without BVH, rendering complex scenes would be impractically slow. This task involves both building the tree structure and efficiently traversing it during ray tracing in \texttt{bvh.c}. The Surface Area Heuristic (SAH) guides the construction to minimize expected traversal cost.

\textbf{Subtask 4.1: BVH Construction with SAH (13 points)}

Implement the \texttt{bvh\_build\_recursive} function that constructs the BVH tree using the Surface Area Heuristic. Your implementation should:

\begin{itemize}
\item Base case: Create a leaf node when the primitive count is below a threshold (typically 1-4 primitives)
\item Compute the bounding box that encloses all primitives in the current node
\item Try splitting along each axis at multiple candidate positions:
  \begin{itemize}
  \item Use binned SAH with 12-16 bins for efficiency
  \item For each bin boundary, compute the cost of splitting there
  \item SAH cost = $C_{traverse} + \frac{A_{left}}{A_{node}} \cdot N_{left} \cdot C_{intersect} + \frac{A_{right}}{A_{node}} \cdot N_{right} \cdot C_{intersect}$
  \item Where A is surface area and N is primitive count
  \item Use typical constants: $C_{traverse} = 1.0$, $C_{intersect} = 1.0$
  \end{itemize}
\item Select the split with minimum cost
\item Partition primitives based on their centroid position relative to the split
\item Recursively build left and right subtrees
\item Handle edge cases: all primitives on one side, identical primitive bounds
\end{itemize}

The quality of the BVH directly impacts rendering performance, so careful implementation of SAH is crucial. Consider falling back to median splitting when SAH doesn't find a good partition.

\textbf{Subtask 4.2: BVH Traversal (12 points)}

Implement the \texttt{bvh\_hit} function that efficiently traverses the BVH to find ray-primitive intersections. Your traversal should:

\begin{itemize}
\item Start at the root node with a traversal stack
\item For each node:
  \begin{itemize}
  \item Test ray-AABB intersection using the provided \texttt{aabb\_hit} function
  \item If no intersection, skip this subtree entirely
  \item For leaf nodes: test the ray against the contained primitive
  \item For internal nodes: add children to the traversal stack
  \end{itemize}
\item Implement ordered traversal:
  \begin{itemize}
  \item Determine which child is closer along the ray
  \item Visit closer child first for better early termination
  \item Use ray direction signs to avoid computing distances
  \end{itemize}
\item Maintain closest hit distance:
  \begin{itemize}
  \item Update t\_max whenever a closer hit is found
  \item Use this to cull nodes that are farther than the current closest hit
  \end{itemize}
\item Use an explicit stack rather than recursion:
  \begin{itemize}
  \item Avoids function call overhead
  \item Prevents stack overflow for deep trees
  \item Enables better control over traversal order
  \end{itemize}
\end{itemize}

Efficient traversal is critical for performance. Even small optimizations in this function can have significant impact on overall rendering time. Pay attention to memory access patterns and minimize redundant calculations.

\subsubsection{Testing and Validation}

To test your implementation, compile and run the path tracer:

\begin{verbatim}
make release          # Compile with optimizations
./pathtracer_gui      # Launch the GUI application
\end{verbatim}

Once the GUI opens, select different scenes from the dropdown menu and click "Render" to test your implementation using provided scenes.

Compare your results with the reference implementation shown in this video: 

\url{https://youtu.be/AVhjcjf5UHM}.

\textbf{For Windows Users:}

Windows users should use Windows Subsystem for Linux (WSL) to run this project:
\begin{itemize}
\item Install WSL2 with Ubuntu distribution
\item Install required dependencies as described in the template's \texttt{README.md}
\end{itemize}

\textbf{Common Issues:}
\begin{itemize}
\item If rendering is extremely slow, verify your BVH implementation
\item If images are black, check your emission handling and path tracing recursion
\item If materials look wrong, verify normal calculations and material scattering
\item Noise in images is expected - increase samples per pixel for cleaner results
\end{itemize}